# #1~#10

## AWS Config
- Configはタグ付けと標準ルールの設定、コンプライアンスのチェック、違反のフラグ付に役立つ

## AWS Inspector
- 自動化されたセキュリティ評価サービスでありAWSにデプロイしたアプリケーションのセキュリティとコンプライアンスを向上させるためのサービス


## Elastic BeanStalk x BlueGreen
- ブルーグリーンデプロイをを実行することでダウンタイムを回避することが可能
- この場合個別に2つの環境をデプロイしてから2つの環境のCNAMEを入れ替えてからすぐに新しいバージョンにトラフィックをリダイレクトする

## ログデータの検索及びフィルタリング
- 各インスタンスでCloudWatch logsエージェントを使用してログを主役することが可能
- メトリフィクスフィルターを定義し、閾値を超過した場合SNSを通じて通知を行うことが可能

- 新しいカスタムメトリクスを容易することは開発工数がかかるため、最適な手段ではない

## kibanaへのアクセスコントロール
- kibanaのアクセス制御のオプションとして「kibanaのAmazon Cognito認証」「プロキシサーバーのある、またはないIPベースのアクセスポリシー設定」がある

### プロキシを使用したkibanaからAmaazon ElasticSerach Serviceへのアクセス
- kibanaはjavascriptアプリケーションであるため、リクエストの送信元はIPアドレスになる。
- IPベースのアクセスコントロールは膨大な数のIPアドレスから制限を行うため現実的とは言えない
- 1つの回避策としてkibanaとESの間にプロキシサーバーを配置すること、これによりIPベースのアクセスポリシーを追加し唯一のIPアドレス(プロキシのIPから)のリクエストを許可できる

※kibanaはOSSのJSアプリケーション、今回の場合EC2にホストしていると理解

## Code Pipeline シーケンス
- テストと手動承認のタイミングに気をつける

### Guard Duty セキュリティ情報の集約
- セキュリティ情報を集約するにはGuardDutyをメンバーアカウントごとに有効化する必要がある

- GuardDutyではセキュリティ脅威の検出が可能である。セキュリティアカウントは監視者アカウントとして機能し他のアカウントを招待する
- メンバーアカウントではGuardDutyを有効化し、招待を受け入れる必要がある

## lamnbdaによるRDSのスナップショット、コピー、復元
- LambdaはRDSのスナップショット、コピー、復元に仕様できる。またRDSのイベント通知を使用して可用性とバックあっぷを追跡できる
- 

- ソリューションとしてセキュリティアカウントにcloudWatchルールを作成して全ての検出結果をKinesis data FIreforseに送信し検出結果をs3バケットへ

## AWS Healthを使用したアクセスキーの検知
- AWS HealthによるAWS_RISK_CREDENTIALS_EXPOSEDイベントを使用してCloudWatchイベントルールを作成し、その送信元をStepFunctionsのアクセスキー削除関数へ

## Cloudfrontによる動的なコンテンツ配信(データ格納場所の特定)
- 複数のリージョンへデプロイするとデータ格納場所を特定できない
- Cloudfrontに関して
  - ELBやEC2にて動的なコンテンツを配信している場合はCloudfrontを通じてコンテンツ配信ネットワークとして利用し、コンテンツのパフォーマンス、可用性、セキュリティをあげることが可能
 
## 別のリージョンへのフェイルオーバー
- バックアップリージョンへのAMIのコピーを自動化する必要がある...AMIは頻繁に更新されるため
- 通常時はインスタンスが実行されないように最大サイズを0に設定
- LambdaはAMIを使用して起動設定を作成しautoScalingGroupへ関連づけインスタンス数を増やしRoute53にてバックアアップリージョンのロードバランサーの指すようにする

## CloudTrailによる変更の監視
- 変更を検出して元に戻すLambdaをトリガーするためにCloudTrailAPIでEvenetBridgeのイベントパスを設定する
- Configでも設定可能だが同様に単体ではなくEventBridgeの設定が必要

## AutoScaling Groupからの一時的なインスタンスの削除
- スタンバイのAuto Scalingライフサイクルを使用すると実際のトラフィックを処理せずにインスタンスに保留できるため、トラブルシューティングに利用することができる
- インスタンスをinservice状態からstanby状態に移行できる。インスタンスを更新してインスタンスを保留にできる。

- Autoscalingのクールダウン期間は前のスケールアクティビティが有効になる前にAutoscalingグループがインスタンスを起動終了しないようにする

## Canaryテスト Route53加重Aレコード
- Canaryテストにはユーザーのサブセットにソフトウェアをリリースできる
- 加重Aレコードを持つroute53を使用して2つの環境にトラフィックを分割できる

- APIGatewayによるCanaryリリースのデプロイでは本稼働リリースとしてデプロイされたままになるため要件に合わない

## セキュリティグループとネットワークACL VPCフローログ
- 外部APIとの連携であるためVPCのアウトバウンドのセキュリテグループとネットワークACLを確認する必要がある
- VPCフローログは許可・拒否されたトラフィックの調査に役立つ

- アプリケーションログはネットワークの問題解決に役立たないため❌
- セキュリティグループはステートフルであるため、インバウンドのSGは送信トラフィックを制御しない


## EFS x EC2 バッチ処理
- EFSはストレージにチェックポイント用の設定データを保存できる。
- EC2はバッチジョブの中断を許容できるため費用対効果の高いソリューションを提供できる
- 事前に作成されたAMIを使用すると起動時間を短縮できる

- ユーザーデータを使用しても起動時間の改善には繋がらないため❌

## CodePipeLineの並行実行 runOrder属性
- CodePipeLineではrunorder属性を指定できるため並列して実行するシーケンスを選択してパイプラインの速度を向上できる

- runOrderでは1番のアクションの値は1、2番のアクションの値は2、3番のアクションの値は3となる
- 並列させたい場合1番のアクションの値は1、2番のアクションの値は2、3番のアクションの値は2とする

## CodeDeploy デプロイメントグループごとのログ管理
- CodeDeployの環境変数であるDEPLOYMENT_GROUP_NAMEを使用してインスタンスがどのデプロイグループに所属しているか識別するスクリプトを作成。この情報を用いてログレベルを設定。
- appspec.yamlを使用してライフサイクルイベントbeforeinstallのフックにスクリプトを仕込む

## Configアグリゲータ マルチリージョンのデータ集約
- configルールを定義しリージョンおよびアカウント全体のデータを収集してレポート用にS3へ保存しSNSで通知できる

## Ec2 SSM RunCommand
-　EC2 RunCommandは既存のインスタンスでコマンドを発行してダウンタイム無しでパッチを適用できる
- またパッチが適用されたAMIに更新できる

## CloudFormation スタック AMIの参照
- CloudFrmationでも他サービスと同様にSSMパラメータストアより変数を入手できる
- また構成管理の際にS3を利用することはスケーラブルではない

## CodeCommit パイプラインを並列
- テスト用のパイプラインはテストブランチを指すことができる一方、本番用コードはマスターブランチを作成することができる
- 開発者はfeatureブランチを使用してコードをテストブランチにマージできる

- 単一のブランチを使うとパイプラインが一つだけになるため注意が必要

## サーバレスアプリケーションを段階的にデプロイする
- Codedeploynの場合canaryデプロイのオプションを含むデプロイリファレンスを指定できる

- Canary...2回の増分で移行されるあらかじめ定義されたCanaryオプションから選択できる。更新されたlambdaのバージョンに最初の数分で移行されるトラフィックの頃のトラフィックが移行される間隔を分間隔で選択できる
- Linear...トラフィックは毎回同じ増分、同じ感覚(分)で移行される
- AllatOnce...一度に全てのトラフィックが移行する

## RDS Aurora
- Auroraのリードレプリカはリージョン間で共有される情報を持つ単一を持つのに役立ち、ローカルインスタンスは顧客がリージョンに制限されることを保証する

- SQLからDyanamoへの移行は工数がかかるため❌

## ハイブリッド環境でSSMを設定する
- SSM用のサーバーとVMの設定が完了するとハイブリッドマシンはマネコンに表示されマネージインスタンスとして表示できる。
- SSMように設定されたインスタンスはマネージドインスタンスとも表示される。コンソールにおいてハイブリッドインスタンスのプレフィックスは`mi-`となる通常のインスタンスは`i-`

## AutoScalingの終了を遅らせてトラブルシュートする EC2インスタンス
- Autoscalingグループのライフサイクルフックを追加してインスタンスの状態がTeminatingからterminatin(wait)に移行するようにする
- この状態ではインスタンスが終了する前にインスタンスにアクセスできるためトラブルシュートに役立つ

## ElastciBeanStalkの保存された設定を使用する
- スナップショットはリードレプリカよりもコストが低い
- EBSの設定を利用するにはRoute53とelasticBeanStalkの設定を別アカウントへコピーする必要がある

- インシデント発生後ではアカウントがブロックされた段階でRoute53が利用できなくなるため❌


## CloudFormationテンプレートを複数のパイプラインで再利用 CloudFormationテンプレートセクション パラメータとマッピング
- 入力パラメータを設定うるために、各環境のCodePipeLineを設定する
- CloudFormationのマッピングを使用して起動される環境に一致するようにEC2のユーザーデータを切り替える

- パラメータ、実行(起動、作成)時に渡すことができる値。テンプレートのresourcesおよびoutputsのセクションのパラメータを参照できる
- マッピング、条件パラメータの指定に使用できるキーと関連するマッピング。resourcesおよびoutputsのセクションでrefindmap組み込み関数を使用することでキーを一致あせることができる

## AutoScaling スケジュールに基づいたスケーリング
- スケジュールされたスケーリングでは独自のスケジューリングができる
- また設定する際は最小サイズと最大サイズを指定する必要がある

## CloudFormation Fn::ImportValue組み込み関数
- ネストされたスタックを作成することができ、ネットワークスタックの出力はFn::ImportValue組み込み関数を使用してresorcesアクションで使用できる
- Fn::ImportValue組み込み関数を利用してネットワークスタックの値を入手する。またFn::ImportValue組み込み関数はresourcesセクションで使用できる

- ネストされたスタックとは...CloudFormationのテンプレートをモジュール化して再利用性と保守性を高めることができる
- 通常のスタックは1つのテンプレートから作成されるがネストされたスタックを使うと親スタックから別のCloudFormationスタックを呼び出すことができる

## AWS SSMインベントリ
-  SSMインベントリではEC2及びオンプレへのコンピューティング環境の可視化を提供する
-  インベントリを使用してマネージドインスタンスからメタデータを収集できる

## SSMオートメーション
-  SSMオートメーションでフローを自動化する必要あり、またSSM RunCommandでChefを更新するとOrganizationがIAMロールを引き受け部門のアカウントでゴールデンイメージを更新できる
-  パッケージの管理にはSSM Run Commandが必要

## CloudFormation creationポリシー cfnシグナル
- CreationPolicyを使用し必要なシグナル数を受信するまでリソースのステータスがCREATE_COMPLETにならないため、全てのソフトウェアが全てのソフトウェアがインストールされた後にスタックの作成を完了させることができる

## CloudWatchログを使用したSSHログインの追跡
- 手動でEC２にログインされたばああいCloudWatchログを使用してSSHを追跡でき、lambdaを通じてタグづけを行うことができる
- タグづけしたインスタンスはEventbridgeによってトリガーされるスケジュールされたジョブで削除できる

## S3ログ管理の耐久性
- バケットポリシーの設定や、S3 MFA Deleteポリシーの設定を行う

## 高可用性
- インスタンスがリージョンまたぐためにはAMIをコピーする必要がある
- 通常は同じリージョン内の別アベいらべりティゾーン

## AWSアカウント間のIAMロールを使用したアクセスの委任
- 管理アカウントの管理者が開発アカウントとテストアカウントの両方でリソースを停止、削除のアクセス権を持たせるには各環境の要のrーるを用意して管理アカウントの管理者にそのロールを付与する必要がある

## VPCピアリング
- VPCピアリングを使用してアプリケーションのインスタンスを中央のVPCに接続する
- VPCピアリングは異なるVPC間でプライベートなネットワークを確立するサービス
  - これにより各アプリケーションが分離されつつも中央のVPCへアクセスできる

## CloudFormation クロススタックの参照
- クロススタックの参照を使用すると、スクリプトは他のスタックからの出力を参照して渡されるパラメータを減らすことができる

- 既存のテンプレートを直すより、新規テンプレートを作成することが工数負担は少ない

## Autoscaling ヘルスチェック ELB
- 必要に応じてELBヘルスチェックを使用するようにAutoScalingグループで設定できる
- これによりロードバランサーによって提供される追加のテストに基づいてグループはインスタンスのヘルスを判断できる

## Kinesis Data Stream
- Kinesis Data StreamはErastiSerachと統合されていない
- Kinesis Data firehorseが使用するデータをElastiSearchにプッシュできる

## CloudFormation カスタムリソース AWS::S3::バケット
- Cloudfortmation削除時にバケットがからでない場合削除できない。
- 全てのリソースが確実に削除できる確かな方法はカスタムリソースを使用して削除がトリガーされる前にバケットを空にすること

## CloudFormation AMIの更新
- AWS::AutoScaling::LaunchConfigrationはautoscalingグループがEC2インスタンスを設定するために使用できる。
- 利用する属性はUpdatePolicy属性AWS::AutoScaling::AutoScalingGroupを利用する

## S3 クロスリージョンレプリケーション
- クロスリージョンレプリケーションはデータをDRリージョンへコピーするのに役立ち、費用対効果を高めるためGracierへ移動する

## SQS リージョン間
- SQSは異なるリージョン間でポーリングしない

## SSM x GitHub
- SSMドキュメントのaws-downloadContnetプラグインを使用しsourceTypeをGitHubを対象としてコンテンツをダウンロードできる

## AWS SSM PatchManager
- PatchMangerはセキュリティ関連のアップデートと他のタイプのアップデートの両方でマネージドインスタンスにパッチを適用するプロセスを自動化する
- アプリケーションとOSの両方へパッチ適用が可能


















