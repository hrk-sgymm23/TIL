# #1~#10

## AWS Config
- Configはタグ付けと標準ルールの設定、コンプライアンスのチェック、違反のフラグ付に役立つ

## AWS Inspector
- 自動化されたセキュリティ評価サービスでありAWSにデプロイしたアプリケーションのセキュリティとコンプライアンスを向上させるためのサービス


## Elastic BeanStalk x BlueGreen
- ブルーグリーンデプロイをを実行することでダウンタイムを回避することが可能
- この場合個別に2つの環境をデプロイしてから2つの環境のCNAMEを入れ替えてからすぐに新しいバージョンにトラフィックをリダイレクトする

## ログデータの検索及びフィルタリング
- 各インスタンスでCloudWatch logsエージェントを使用してログを主役することが可能
- メトリフィクスフィルターを定義し、閾値を超過した場合SNSを通じて通知を行うことが可能

- 新しいカスタムメトリクスを容易することは開発工数がかかるため、最適な手段ではない

## kibanaへのアクセスコントロール
- kibanaのアクセス制御のオプションとして「kibanaのAmazon Cognito認証」「プロキシサーバーのある、またはないIPベースのアクセスポリシー設定」がある

### プロキシを使用したkibanaからAmaazon ElasticSerach Serviceへのアクセス
- kibanaはjavascriptアプリケーションであるため、リクエストの送信元はIPアドレスになる。
- IPベースのアクセスコントロールは膨大な数のIPアドレスから制限を行うため現実的とは言えない
- 1つの回避策としてkibanaとESの間にプロキシサーバーを配置すること、これによりIPベースのアクセスポリシーを追加し唯一のIPアドレス(プロキシのIPから)のリクエストを許可できる

※kibanaはOSSのJSアプリケーション、今回の場合EC2にホストしていると理解

## Code Pipeline シーケンス
- テストと手動承認のタイミングに気をつける

### Guard Duty セキュリティ情報の集約
- セキュリティ情報を集約するにはGuardDutyをメンバーアカウントごとに有効化する必要がある

- GuardDutyではセキュリティ脅威の検出が可能である。セキュリティアカウントは監視者アカウントとして機能し他のアカウントを招待する
- メンバーアカウントではGuardDutyを有効化し、招待を受け入れる必要がある

## lamnbdaによるRDSのスナップショット、コピー、復元
- LambdaはRDSのスナップショット、コピー、復元に仕様できる。またRDSのイベント通知を使用して可用性とバックあっぷを追跡できる
- 

- ソリューションとしてセキュリティアカウントにcloudWatchルールを作成して全ての検出結果をKinesis data FIreforseに送信し検出結果をs3バケットへ

## AWS Healthを使用したアクセスキーの検知
- AWS HealthによるAWS_RISK_CREDENTIALS_EXPOSEDイベントを使用してCloudWatchイベントルールを作成し、その送信元をStepFunctionsのアクセスキー削除関数へ

## Cloudfrontによる動的なコンテンツ配信(データ格納場所の特定)
- 複数のリージョンへデプロイするとデータ格納場所を特定できない
- Cloudfrontに関して
  - ELBやEC2にて動的なコンテンツを配信している場合はCloudfrontを通じてコンテンツ配信ネットワークとして利用し、コンテンツのパフォーマンス、可用性、セキュリティをあげることが可能
 
## 別のリージョンへのフェイルオーバー
- バックアップリージョンへのAMIのコピーを自動化する必要がある...AMIは頻繁に更新されるため
- 通常時はインスタンスが実行されないように最大サイズを0に設定
- LambdaはAMIを使用して起動設定を作成しautoScalingGroupへ関連づけインスタンス数を増やしRoute53にてバックアアップリージョンのロードバランサーの指すようにする

## CloudTrailによる変更の監視
- 変更を検出して元に戻すLambdaをトリガーするためにCloudTrailAPIでEvenetBridgeのイベントパスを設定する
- Configでも設定可能だが同様に単体ではなくEventBridgeの設定が必要

## AutoScaling Groupからの一時的なインスタンスの削除
- スタンバイのAuto Scalingライフサイクルを使用すると実際のトラフィックを処理せずにインスタンスに保留できるため、トラブルシューティングに利用することができる
- インスタンスをinservice状態からstanby状態に移行できる。インスタンスを更新してインスタンスを保留にできる。

- Autoscalingのクールダウン期間は前のスケールアクティビティが有効になる前にAutoscalingグループがインスタンスを起動終了しないようにする

## Canaryテスト Route53加重Aレコード
- Canaryテストにはユーザーのサブセットにソフトウェアをリリースできる
- 加重Aレコードを持つroute53を使用して2つの環境にトラフィックを分割できる

- APIGatewayによるCanaryリリースのデプロイでは本稼働リリースとしてデプロイされたままになるため要件に合わない

## セキュリティグループとネットワークACL VPCフローログ
- 外部APIとの連携であるためVPCのアウトバウンドのセキュリテグループとネットワークACLを確認する必要がある
- VPCフローログは許可・拒否されたトラフィックの調査に役立つ

- アプリケーションログはネットワークの問題解決に役立たないため❌
- セキュリティグループはステートフルであるため、インバウンドのSGは送信トラフィックを制御しない


## EFS x EC2 バッチ処理
- EFSはストレージにチェックポイント用の設定データを保存できる。
- EC2はバッチジョブの中断を許容できるため費用対効果の高いソリューションを提供できる
- 事前に作成されたAMIを使用すると起動時間を短縮できる

- ユーザーデータを使用しても起動時間の改善には繋がらないため❌

## CodePipeLineの並行実行 runOrder属性
- CodePipeLineではrunorder属性を指定できるため並列して実行するシーケンスを選択してパイプラインの速度を向上できる

- runOrderでは1番のアクションの値は1、2番のアクションの値は2、3番のアクションの値は3となる
- 並列させたい場合1番のアクションの値は1、2番のアクションの値は2、3番のアクションの値は2とする

## CodeDeploy デプロイメントグループごとのログ管理
- CodeDeployの環境変数であるDEPLOYMENT_GROUP_NAMEを使用してインスタンスがどのデプロイグループに所属しているか識別するスクリプトを作成。この情報を用いてログレベルを設定。
- appspec.yamlを使用してライフサイクルイベントbeforeinstallのフックにスクリプトを仕込む

## Configアグリゲータ マルチリージョンのデータ集約
- configルールを定義しリージョンおよびアカウント全体のデータを収集してレポート用にS3へ保存しSNSで通知できる

## Ec2 SSM RunCommand
-　EC2 RunCommandは既存のインスタンスでコマンドを発行してダウンタイム無しでパッチを適用できる
- またパッチが適用されたAMIに更新できる

## CloudFormation スタック AMIの参照
- CloudFrmationでも他サービスと同様にSSMパラメータストアより変数を入手できる
- また構成管理の際にS3を利用することはスケーラブルではない

## CodeCommit パイプラインを並列
- テスト用のパイプラインはテストブランチを指すことができる一方、本番用コードはマスターブランチを作成することができる
- 開発者はfeatureブランチを使用してコードをテストブランチにマージできる

- 単一のブランチを使うとパイプラインが一つだけになるため注意が必要

## サーバレスアプリケーションを段階的にデプロイする
- Codedeploynの場合canaryデプロイのオプションを含むデプロイリファレンスを指定できる

- Canary...2回の増分で移行されるあらかじめ定義されたCanaryオプションから選択できる。更新されたlambdaのバージョンに最初の数分で移行されるトラフィックの頃のトラフィックが移行される間隔を分間隔で選択できる
- Linear...トラフィックは毎回同じ増分、同じ感覚(分)で移行される
- AllatOnce...一度に全てのトラフィックが移行する 





