# 動的計画法
## 動的計画法の例題
```
N個の足場があります。i番目の足場の高さはhiです
蛙は最初0番目の高さの足場にいて、以下いずれかの行動を繰り返してN-1番目の足場を目指す
- 足場iから足場i+1へ移動する。この時コストとして|hi-h(i+1)|を支払う
- 足場iから足場i+2へ移動する。この時コストとして|hi-h(i+2)|を支払う
蛙が足場０から足場N-１まで到達するのに必要なコストの総和は？
(2<=N<=10^5)
```

- 例としてN=7,h=[2,9,4,5,1,6,10]の時
- 足場2から4に移動する時|4-1|=3となるため,頂点2から4への変に値3がつけらる
- このことを辺の**重み**という


- 一般に頂点0から頂点i(>=2)へと至る経路は2つに分けて考えることができる
  - 最後の辺が(i-1,i)
  - 最後の辺が(i-2,i)

- よって一般に頂点0から頂点iへの最短経路長を求める関数を`rec`とした時
```
rec(i) = min(rec(i-1)+|hi-h(i-1)|, rec(i-2)+|hi-h(i-2)) (i>=2)
```
という関係が成立する

- つまり`rec`は
  - 「頂点0から頂点i-1までの最短経路を移動して最後に辺(i-1,i)を辿る時」と
  - 「頂点0から頂点i-２までの最短経路を移動して最後に辺(i-1,i)を辿る時」
  の小さい方に一致する

- しかし再帰関数で解くと同じ計算を行う箇所があり無駄が生じる
- このような無駄をはぶくために**各引数にたいする答えをメモする**という方法が有効
- rec(i)を呼び出した際にrec(i)の値が既に計算済みであればdp[i]の値を直接返すようにする

## ボトムアップな動的計画法
- `rec`の解を`dp`にメモしていく代わりに再帰関数を用いずにfor文を用いてdp[1],dp[2],...dp[N-1]と順に求めていく方法
- dpの値を求めるため次の2つを比較する
  - 頂点i-1まで最短経路で行ってから、頂点iへと至る方法の最小コスト:`dp[i-1]+abs(h[i]-h[i-1])`
  - 頂点i-2まで最短経路で行ってから、頂点iへと至る方法の最小コスト:`dp[i-2]+abs(h[i]-h[i-2])`
