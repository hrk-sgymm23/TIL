# 計算量を求める例

## 例1: 偶数の列挙 O(N)
 ```
 N = int(input())
 for i in range(2, N+1, 2)
    print(i)
 ```
 
 - 上記は1以上N以下の偶数を列挙するコード。上記のコードにおいて反復回数はN/2回(小数点以下切り下げ)。これは概ねNに比例する(比例係数は1/2)と言えるので、計算量はO(N)と評価できる

 ## 例2: 1からNまでの総和O(1)
 ```
 N = int(input())
 print(N* (N+1) // 2)
 ```
 - 上記のプログラムは1からNまでの総和を求めるもので等差数列の和の公式**1+2+..(N=N(N+1))/2**を用いています。これらの計算量はNの大きさに依存していないため計算量はO(N)
 - 問題の大きさに依らず一定時間内にプログラムが終了するアルゴリズムの計算量は**定数時間**であると言える

 ## 例3: 最近点対問題 O(N^2)
 - 二次元平面上にN個の点(x0,y0),(x1,y1),(x2,y2),,,(xn-1,yn-1)が与えられてその内2点の距離の二乗の最小値を求める問題(最近点対問題)
 - 簡単のためxi,yiは整数とする。このとき2点間の距離の2乗は常に整数のなる
 - この問題は2重forを用いた全探索で溶ける。具体的には0<=i<j<Nを満たす添字の組みi,jを全て調べる
 - 各組i,jに対して2点(xi,yi),(xj,yj)間の距離を求めて、その内の最小値を求める
```
# 大値を用意
INF = 2 ** 30

N = int(input())
x = list(map(int, input().split()))
y = list(map(int, input().split()))

# 距離の二乗の最小値を表す変数
smallest = INF

for i in range(N):
    # 同じ組み合わせの計算を避けるためi+1する
    for j in range(i+1, N):
        dx, dy = x[i]-x[j], y[i]-y[j]
        dist = dx**2 + dy**2

        smallest = (smallest, dist)

print(smallest)
``` 
- 上記のコードは二重for文のためO(N^2)と判断できそうだが、実際はどうか
- for文で走査する添字i,jのくみが何個あるか考える
- i=0の時、添字jの動く範囲は1,2,3,,,N-1のN-1個
- i=1の時、添字jの動く範囲は2,3,,,N-1のN-2個
- i=N-1の時、添字jの動く範囲はN-1の1個

- 以上より添字の組みとしてありうるものの個数は
```
(N-1)+(N-2)+(N-3)+...+1 = N^2/2 - N/2 
```
よって計算量はO(N^2)となった

## 例4: 二進法展開 O(log N)
- 整数Nを2進法で表した時、何個の1が確認できるか
- これは整数Nを二進法で表した時の各桁の和と言い換えることができる
```
N = int(input())
sum = 0
while N > 0:
    sum += N%2
    N //= 2
return sum
```
- 上記コードの計算量を考える。whileの反復回数を評価する
- 反復のたびにNが半減している
  - Nが65536の時、65536 > 32768 > 16384 ...(17回半減)
- 一般にN = 2^kと表せる時、while文に入る回数はK+1 =　logN+1となる
- N = 2^kと表せない場合であってもwhile文に入る回数は概ねlogN回程度になる
- よって上記コードの計算量はO(logN)になる

## 例5: ソートO(NlogN)
- ソートする要素数をNとしてO(NlogN)の計算量を持つ
- O(N^2)ではなくO(NlogN)であることが大変重要である
- AtCoderではN<=10^5という制約が度々出る。N=10^5の時
  - N^2=10000000000
  - NlogN=1660964(小数点切り捨て)
  となる
- もしソートにかかる計算量がO(N^2)の時、そのような制約の問題に対し、ソートは実行できない
