# 計算量を求める例

## 例1: 偶数の列挙 O(N)
 ```
 N = int(input())
 for i in range(2, N+1, 2)
    print(i)
 ```
 
 - 上記は1以上N以下の偶数を列挙するコード。上記のコードにおいて反復回数はN/2回(小数点以下切り下げ)。これは概ねNに比例する(比例係数は1/2)と言えるので、計算量はO(N)と評価できる

 ## 例2: 1からNまでの総和O(1)
 ```
 N = int(input())
 print(N* (N+1) // 2)
 ```
 - 上記のプログラムは1からNまでの総和を求めるもので等差数列の和の公式**1+2+..(N=N(N+1))/2**を用いています。これらの計算量はNの大きさに依存していないため計算量はO(N)
 - 問題の大きさに依らず一定時間内にプログラムが終了するアルゴリズムの計算量は**定数時間**であると言える

 ## 例3: 最近点対問題 O(N^2)
 - 二次元平面上にN個の点(x0,y0),(x1,y1),(x2,y2),,,(xn-1,yn-1)が与えられてその内2点の距離の二乗の最小値を求める問題(最近点対問題)
 - 簡単のためxi,yiは整数とする。このとき2点間の距離の2乗は常に整数のなる
 - この問題は2重forを用いた全探索で溶ける。具体的には0<=i<j<Nを満たす添字の組みi,jを全て調べる
 - 各組i,jに対して2点(xi,yi),(xj,yj)間の距離を求めて、その内の最小値を求める
```
# 大値を用意
INF = 2 ** 30

N = int(input())
x = list(map(int, input().split()))
y = list(map(int, input().split()))

# 距離の二乗の最小値を表す変数
smallest = INF

for i in range(N):
    # 同じ組み合わせの計算を避けるためi+1する
    for j in range(i+1, N):
        dx, dy = x[i]-x[j], y[i]-y[j]
        dist = dx**2 + dy**2

        smallest = (smallest, dist)

print(smallest)
``` 
- 上記のコードは二重for文のためO(N^2)と判断できそうだが、実際はどうか
- for文で走査する添字i,jのくみが何個あるか考える
- i=0の時、添字jの動く範囲は1,2,3,,,N-1のN-1個
- i=1の時、添字jの動く範囲は2,3,,,N-1のN-2個
- i=N-1の時、添字jの動く範囲はN-1の1個

- 以上より添字の組みとしてありうるものの個数は
```
(N-1)+(N-2)+(N-3)+...+1 = N^2/2 - N/2 
```
よって計算量はO(N^2)となった