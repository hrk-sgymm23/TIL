# ペアリング
# 各文字列内のABは数えて後で合算
# 文字列を分類
# 1..."BxxxA" c1
# 2..."xxxA"　c2
# 3..."Bxxx" c3
# 4..."xxx" c4

# c2<=c3の時(c2>=c3でも同様)
# 1,2の右端のAが全て1,3の左と連結できれば良い
# まずパターン１を連結させ末尾に3を繋げる
# "BxxxA"+"BxxxA"+"Bxxx"←この連結した文字を一つのパターン3と認識できる
# よって
# 文字列はパターン2が　c2個
# 文字列はパターン3が　c3個 と同一視できる

# 以上より
# c2,c3の一報が1以上である場合、論理限界である　
# c1+min(c2,c3)
# が生成できる

# まとめ
# - 各文字列のABを求め後で合算Tとする
# - 各文字列を4パターンに分岐する
# - c2=c3=0の時、答えは T+max(c1-1,0)
# - それ以外の時、答えは T+c1+(c2,c3)

N = int(input())

T, c1, c2, c3 = 0, 0, 0, 0

for i in range(N):
    S = input()
    T += S.count("AB")

    if S[0] == "B" and S[-1] == "A":
        c1 += 1
    elif S[-1] == "A":
        c2 += 1
    else :
        c3 += 1

if c2 == c3 == 0:
    # パターン１の数-1分ABが生まれるため c1-1
    print(T + max(c1-1,0))
else:
    print(c1, c2, c3)
    # 各文字列に含まれるABの数+パターン１の数+2,3の少ない方のパターンの数
    print(T + c1 + min(c2, c3))
    