# About InterLeaving

## インターリービングについて調べる

- [A/Bテストより10~100倍効率的なランキング評価手法　インターリービング（Interleaving）のまとめと実践](https://qiita.com/mpkato/items/99bd55cc17387844fd62#balanced-interleaving-joachims-2002a-2003)

## Balanced interleaving (Joachims 2002a, 2003)

https://qiita.com/mpkato/items/99bd55cc17387844fd62#balanced-interleaving-joachims-2002a-2003

```python
L = [] # 生成されるランキング  
k_A, k_B = 0, 0 # 各ランクキング中で参照している順位を表すポインタ
is_A_first = random_bit() # TrueかFalseをランダムで返す。最初にどちらのランキングの検索結果を利用するか決める。
while len(L) < k and k_A < len(A) and k_B < len(B):
    if k_A < k_B or (k_A == k_B and is_A_first):
        if not A[k_A] in L:
            L.append(A[k_A]) # A[k_A]がすでにLに含まれていなければ末尾に追加
        k_A += 1
    else:
        if not B[k_B] in L:
            L.append(B[k_B]) # B[k_B]がすでにLに含まれていなければ末尾に追加
        k_B += 1      
```

## テストケースを作成する

### 以下テストケース

- 返される要素数が期待する値か
- 1ページ内で重複がないようにする
- 1ページ目で表示されたIDが他のページで表示されていないか
- `per_page`で要求されたページより多くのページを返していないか
- 一度も表示されないIDがないか
  - 関数 new_algorithm と関数 old_algorithmのどちらかで返された募集は必ずinterleavingのどこかのページで返す必要がある
 
## 作業メモ

- パフォーマンスと正確性のトレードオフを考慮したい

### パフォーマンス重視の場合

- ユースケースとしてリアルタイム性が求められる場合のバックエンドサーバーおよびDBへの負荷を抑えるためといった考慮事項が考えらえる
- 設計方針
  - ページネーション分の
 

# 回答

# 2つの設計方針

## 方針1: ページネーション分のIDを取得後にインターリーブ処理を実行

### 方針1: ページネーション分のIDを取得後にインターリーブ処理
- ページ番号 (page) と 1 ページあたりのアイテム数 (per_page) を基に、ページに必要なデータの範囲（start_idx ～ end_idx）を計算。
- 各アルゴリズムで、必要な範囲だけの ID を事前に取得。
- 例: 新アルゴリズム、旧アルゴリズムでそれぞれ start_idx ～ end_idx のデータを取得。必要なデータが揃った後に、インターリーブ処理を行い、結果を整形。


## 方針2: ID全権取得後、インターリーブ処理をかけてページネーション分に分割
- 新アルゴリズムと旧アルゴリズムから、全件の ID をそれぞれ取得。
- 全件のデータをインターリーブ処理して、交互に並べた結果を作成。
- 作成した結果をページネーションに基づいて、必要な範囲（start_idx ～ end_idx）を切り出して返却。

## 決定した方針

### 選んだ方針: 方針2
- 方針1のページネーションを実装する方法の例としてリクエストされた該当するページのIDを取得することがバックエンドサーバー、DBへの負担を軽減することにつながる。
- しかしID取得のアルゴリズム内で取得するIDに更新などがあった際にデータの重複がありデータの選出の正確性に問題が出る可能性がある。
- 一方で方針の2ではIDを全件取得するため、バックエンドサーバー、DBへの負担が懸念されるが全件に対してインターリーブ処理とページネーションの分割を行うため、データ選出の正確性を担保することができる。
- 今回の目的である新旧のアルゴリズムを比較するためのインターリーブし検証することであるため、データ選出の正確性を担保することのプライオリティーが一番高くなる。
- よって方針2を選択した。

# GPT編集版

## 回答
## 2つの設計方針
### 方針1: ページネーション分のIDを取得後にインターリーブ処理を実行

- ページ番号 (page) と 1 ページあたりのアイテム数 (per_page) を基に、必要なデータの範囲を計算。
- 各アルゴリズムから、範囲内のデータを取得し、インターリーブ処理を実行。

### 方針2: ID全件取得後、インターリーブ処理をかけてページネーション分に分割

- 新旧両方のアルゴリズムから全件のIDを取得。
- 全データをインターリーブ処理後、ページごとに分割して返却。

## 選んだ方針: 方針2

### 理由: 正確性の確保
- 方針1では、ID取得中にデータが更新されたり重複した場合、選出結果に誤差が生じる可能性がある。
- 一方、方針2は全データを対象に処理を行うため、正確なデータ選出が可能。

- 本件の目的は、新旧アルゴリズムを比較するためのインターリーブ処理を行い、正確な検証結果を得ることである。
- このため、正確性が最優先となり、方針2を選択した。


## プロンプト

```
# 2つの設計方針

## 方針1: ページネーション分のIDを取得後にインターリーブ処理を実行

### 方針1: ページネーション分のIDを取得後にインターリーブ処理
- ページ番号 (page) と 1 ページあたりのアイテム数 (per_page) を基に、ページに必要なデータの範囲（start_idx ～ end_idx）を計算。
- 各アルゴリズムで、必要な範囲だけの ID を事前に取得。
- 例: 新アルゴリズム、旧アルゴリズムでそれぞれ start_idx ～ end_idx のデータを取得。必要なデータが揃った後に、インターリーブ処理を行い、結果を整形。


## 方針2: ID全権取得後、インターリーブ処理をかけてページネーション分に分割
- 新アルゴリズムと旧アルゴリズムから、全件の ID をそれぞれ取得。
- 全件のデータをインターリーブ処理して、交互に並べた結果を作成。
- 作成した結果をページネーションに基づいて、必要な範囲（start_idx ～ end_idx）を切り出して返却。

## 決定した方針

### 選んだ方針: 方針2
- 方針1のページネーションを実装する方法の例としてリクエストされた該当するページのIDを取得することがバックエンドサーバー、DBへの負担を軽減することにつながる。
- しかしID取得のアルゴリズム内で取得するIDに更新などがあった際にデータの重複がありデータの選出の正確性に問題が出る可能性がある。
- 一方で方針の2ではIDを全件取得するため、バックエンドサーバー、DBへの負担が懸念されるが全件に対してインターリーブ処理とページネーションの分割を行うため、データ選出の正確性を担保することができる。
- 今回の目的である新旧のアルゴリズムを比較するためのインターリーブし検証することであるため、データ選出の正確性を担保することのプライオリティーが一番高くなる。
- よって方針2を選択した。


上記の二つの設計方針の回答において以下を確認/修正して
- 日本語の言い回しの間違い
- 誤字脱字の修正
- 冗長な文章があれば省略
```
